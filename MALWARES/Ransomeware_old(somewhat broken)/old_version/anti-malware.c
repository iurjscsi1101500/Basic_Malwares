#include <stdio.h>
#include <string.h>
#include <openssl/aes.h>
#include <dirent.h>
#include <sys/stat.h>
#include <stdlib.h>

#define AES_BLOCK_SIZE 16
#define MAX_PATH_LENGTH 256

void decryptFile(const char *inputFilename, const char *key) {
    FILE *file = fopen(inputFilename, "rb+");

    if (!file) {
        perror("Error opening file");
        return;
    }

    struct stat st;
    if (stat(inputFilename, &st) != 0) {
        perror("Error getting file size");
        fclose(file);
        return;
    }

    long fileSize = st.st_size;
    unsigned char iv[AES_BLOCK_SIZE];
    memset(iv, 0, sizeof(iv));

    AES_KEY aesKey;
    AES_set_decrypt_key((const unsigned char *)key, 128, &aesKey);

    unsigned char chunk[16]; // 16 bytes chunk size

    while (1) {
        size_t bytesRead = fread(chunk, 1, sizeof(chunk), file);
        if (bytesRead == 0) break; // Reached end of file
        AES_decrypt(chunk, chunk, &aesKey);
        fseek(file, -bytesRead, SEEK_CUR);
        fwrite(chunk, 1, bytesRead, file);
        fflush(file);
    }

    fclose(file);
}

void decryptFolder(const char *folderPath, const char *key) {
    DIR *dp = opendir(folderPath);

    if (!dp) {
        perror("Error opening directory");
        return;
    }

    struct dirent *entry;

    while ((entry = readdir(dp))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            // Skip "." and ".." entries
            continue;
        }

        char entryPath[MAX_PATH_LENGTH];
        snprintf(entryPath, sizeof(entryPath), "%s/%s", folderPath, entry->d_name);

        struct stat st;
        if (stat(entryPath, &st) != 0) {
            perror("Error getting file status");
            continue;
        }

        if (S_ISDIR(st.st_mode)) {
            // If it's a directory, recursively decrypt its contents
            decryptFolder(entryPath, key);
        } else if (S_ISREG(st.st_mode)) {
            // If it's a regular file, decrypt it
            decryptFile(entryPath, key);
        }
    }

    closedir(dp);
}

int main() {
    char directoryPath[MAX_PATH_LENGTH];
    const char *key = "C1xR8jAuj43MNlqsDxYuvatkdheNF8kh3d40Kpv5N0m8ILxygHdA2lg8OtFyZcvXrwpWEncE4FL0epSn2UvJGTcGADs9rp6QoU6fBqmcUP9IPAHtaRfuc36DnfoCKTlN2hHgfeZSRfZuILjRrerUMbWGR0Nc9XiTm4GC4ugUMJRwDaPt0YXtzb1LLV4tXrjNBnDzD8WrXhxEYudXIramMrPdbRGojI6UcHPt8pZsWUPJPA5niMKpdijRXngtSX7qyg5nvRfj9nNzZ5mpyNNEF6zao17rchfrdiNGFGgYuO3PxtN3Utw5sE6pyMQ6V6C"; // Replace with your own key

    printf("Enter the directory path to decrypt: ");
    fgets(directoryPath, sizeof(directoryPath), stdin);

    // Remove newline character from the directory path
    directoryPath[strcspn(directoryPath, "\n")] = '\0';

    decryptFolder(directoryPath, key);

    return 0;
}
